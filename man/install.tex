%$Id: install.tex,v 25.95 2006/08/26 01:26:53 al Exp $
% man install .
% Copyright (C) 2001 Albert Davis
% Author: Albert Davis <aldavis@ieee.org>
%
% This file is part of "Gnucap", the Gnu Circuit Analysis Package
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
% 02110-1301, USA.
%------------------------------------------------------------------------
\chapter{Installation}

%HEVEA\cutdef[0]{section}

\section{The easy way}

For this version, you can use either the GNU style "configure;make"
style build process, or the old ACS style.  If it works for you, use
the GNU style.

For the GNU style build, just type "./configure" then "make" from the
project's root directory.  This will configure both the model compiler
and the simulator, and then build the model compiler first, then use
it to build the simulator.  Then you can use ``make install'' (as
root) to install it.  That should be all that is needed.  You do not
to read any further.

\section{The old easy way}

Instead of ``./configure'', you can do ``./configure.old''.  This is a
script that is a subset of the usual ``./configure'', but builds the
development makefiles.  Try ``./configure.old'', then ``make''.

\section{If that doesn't work}

This version requires a two-step build.  First you build the model
compiler, then you build the simulator.

So ..
cd to modelgen, type make (as below)
then go back down and cd to src, type make (as below)

If it fails, go into its build directory (the one containing the .o
files) and manually create a symbolic link to the model compiler.


"Type make" really means ......

Usually, you can just type "make".  This will make a "release"
version, with optimization on and extra debug code out.  It will build
in the O subdirectory.  This assumes you have g++ in a reasonable
configuration.

To make a "debug" version (slow, with additional error checking), type
"make debug".  If you have a recent g++ compiler, this should build it
in the O-DEBUG subdirectory.

If your compiler is not g++, but called by "CC", try "make CC".  This
is believed to work with some compilers.  Some of them do not
implement the full language, so they cannot be used.  Try it.  There
is a special one "sun4-CC" for a Sun running Solaris with the most
recent version of Sun's compiler.  It will not work with older
versions.

To make a "release" version for a particular system, type make
followed by your system type, such as "make linux".  This will build
it in a subdirectory (in this case LINUX).  With this method, you can
build for multiple systems in the same directory.

Look at "Makefile" for a list of supported systems, and clues of how
to do it on others.  Most of them have not been tried in years.

If it doesn't work, edit only a "Make2.*" file, and possibly {\tt md.h} or
{\tt md.cc}.  All nonportabilities are confined to these files.

It does require a recent and proper C++ compiler with a proper
library, including STL.  Gnu compilers as old as 3.3 are suppported.
Version 2.95 may work.  Anything older than that will probably not
work.  Any high quality C++ compiler available today should work.

To install ....

Just move or copy the executable to where you want it.

\section{Details, custom compilation}

Read this section if you have problems or want to know more.  It is
not necessary most of the time.

Most of the development of Gnucap was done on a PC running Linux.  I have
also compiled it successfully on several other systems, listed at the
end of this file.  Other users have ported it to several other
systems.  Some of the files are included in the distribution.  They
may not have been tested in the latest release.  It should compile
with any ``standard'' C++ compiler.  It should produce no warnings when
compiled with the switches in the supplied makefiles and g++, except
those due to the system supplied header files being defective.  It
requires templates, but not exceptions.

All source files are in the src and modelgen directories.  I use
subdirectories for the .o files each supported machine.  This makes it
possible to install it on several different machines all sharing the
same file system.

To avoid maintaining multiple versions of Makefiles, I have broken
them up to parts that must be concatenated: Make1.*, Make2.*, Make3.*.
In general, to make a Makefile for your system, cat one of each.  See
the Makefile for details.  I have automated this for some systems.
Just ``make your-machine'', if it is one that is supported.  In some
cases, the Makefile will compile both a ``release'' and ``debug''
version.  In these cases, type ``make your-machine-release'' or ``make
your-machine-debug'' depending on which you want.  This will make the
appropriate Makefile, cd to where the .o's go and run make from there.
For porting information for specific machines, read its {\tt Make2.*}
file.

I assume that make will follow ``VPATH'' to find the sources.  This
system makes it possible to manage several platforms on a single file
system which may be NFS mounted to all the supported machines.  If
your make does not support VPATH, there are three options.  The
preferred method on unix based systems is to cd to where the .o's go
and type {\tt ln -s ../*.cc ../*.h .}.  (The command ends with a dot.)
This will set up links so the Makefiles will work as intended.  In
some cases we have set up the Makefile to do this automatically.  The
second method, which may be needed on systems that don't have symbolic
links is to copy the .c and .h files to satisfy make.  The third
option, where you have only one computer, is to move the machine
specific Makefile to the src directory and run make from there.

If you have g++ on a unix type system that is not directly supported,
try to compile it by just typing {\tt make}.  In most cases this will
do it, but you may get a few warnings.  If it doesn't work, look in
the file {\tt md.h} for hints.  Just plain {\tt make} will build a
guess at a release version, assuming a Linux-like system with GNU
tools.

If you want a development version with additional debugging enabled,
type {\tt make debug}.  This results in a significant speed penalty.

Then make the installation version, select the machine you have from
the make file and make that.  The machine specific versions will
build in their own directory, have debugging code disabled, and
options are set for best speed.  The general purpose {\tt make g++}
builds a version that is optimized as much as it can be in the
general case.

If you have a cfront-type compiler, called {\tt CC}, and your system
is not directly supported, try it first by typing {\tt make CC}.  Again,
you may get a few warnings but it should work.  Look in the file
{\tt md.h} for hints, if it doesn't work, or if the warnings look
serious.

Since C++ is an evolving language, there are some known portability
problems.  All of them are due to compilers that do not implement the
standard correctly.  Since the problems will go away in time, I have
chosen not to burden the code with them, except where a few
mainstream systems fail.  All dependencies should be confined to the
two files {\tt md.h} and {\tt md.cc}, if possible.

There should be NO non-portable code anywhere but the {\tt md\_*}
files.  If a fix is absolutely necessary elsewhere, {\tt \#define} some
symbol in {\tt md.h} and refer to it elsewhere.  Then consider it to
be temporary.

%HEVEA\cutend
%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
