<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Details, custom compilation
</TITLE>
</HEAD>
<BODY >

<H2><A NAME="htoc102">5.3</A>&nbsp;&nbsp;Details, custom compilation</H2>
Read this section if you have problems or want to know more. It is
not necessary most of the time.<BR>
<BR>
Most of the development of Gnucap was done on a PC running Linux. I have
also compiled it successfully on several other systems, listed at the
end of this file. Other users have ported it to several other
systems. Some of the files are included in the distribution. They
may not have been tested in the latest release. It should compile
with any ``standard'' C++ compiler. It should produce no warnings when
compiled with the switches in the supplied makefiles and g++, except
those due to the system supplied header files being defective. It
requires templates, but not exceptions.<BR>
<BR>
All source files are in the src and modelgen directories. I use
subdirectories for the .o files each supported machine. This makes it
possible to install it on several different machines all sharing the
same file system.<BR>
<BR>
To avoid maintaining multiple versions of Makefiles, I have broken
them up to parts that must be concatenated: Make1.*, Make2.*, Make3.*.
In general, to make a Makefile for your system, cat one of each. See
the Makefile for details. I have automated this for some systems.
Just ``make your-machine'', if it is one that is supported. In some
cases, the Makefile will compile both a ``release'' and ``debug''
version. In these cases, type ``make your-machine-release'' or ``make
your-machine-debug'' depending on which you want. This will make the
appropriate Makefile, cd to where the .o's go and run make from there.
For porting information for specific machines, read its <TT>Make2.*</TT>
file.<BR>
<BR>
I assume that make will follow ``VPATH'' to find the sources. This
system makes it possible to manage several platforms on a single file
system which may be NFS mounted to all the supported machines. If
your make does not support VPATH, there are three options. The
preferred method on unix based systems is to cd to where the .o's go
and type <TT>ln -s ../*.cc ../*.h .</TT>. (The command ends with a dot.)
This will set up links so the Makefiles will work as intended. In
some cases we have set up the Makefile to do this automatically. The
second method, which may be needed on systems that don't have symbolic
links is to copy the .c and .h files to satisfy make. The third
option, where you have only one computer, is to move the machine
specific Makefile to the src directory and run make from there.<BR>
<BR>
If you have g++ on a unix type system that is not directly supported,
try to compile it by just typing <TT>make</TT>. In most cases this will
do it, but you may get a few warnings. If it doesn't work, look in
the file <TT>md.h</TT> for hints. Just plain <TT>make</TT> will build a
guess at a release version, assuming a Linux-like system with GNU
tools.<BR>
<BR>
If you want a development version with additional debugging enabled,
type <TT>make debug</TT>. This results in a significant speed penalty.<BR>
<BR>
Then make the installation version, select the machine you have from
the make file and make that. The machine specific versions will
build in their own directory, have debugging code disabled, and
options are set for best speed. The general purpose <TT>make g++</TT>
builds a version that is optimized as much as it can be in the
general case.<BR>
<BR>
If you have a cfront-type compiler, called <TT>CC</TT>, and your system
is not directly supported, try it first by typing <TT>make CC</TT>. Again,
you may get a few warnings but it should work. Look in the file
<TT>md.h</TT> for hints, if it doesn't work, or if the warnings look
serious.<BR>
<BR>
Since C++ is an evolving language, there are some known portability
problems. All of them are due to compilers that do not implement the
standard correctly. Since the problems will go away in time, I have
chosen either not to burden the code with them, except where a few
mainstream systems fail. All dependencies should be confined to the
two files <TT>md.h</TT> and <TT>md.cc</TT>, if possible.<BR>
<BR>
Here are some possible problems that are no longer supported:
<DL COMPACT=compact><DT><B>bool</B><DD> The C++ language includes a type <TT>bool</TT>, which is not
implemented in older compilers. Older compilers just use <TT>int</TT>,
and fake it with a <TT>typedef</TT> or <TT>#define</TT>, neither of which
work correctly.</DL>
Here are some problems that you will need to deal with creatively:
<DL COMPACT=compact><DT><B>missing files or functions</B><DD> Another cause of a port to fail
is missing header files or missing function prototypes. Sometimes
missing functions can be a problem. The solution to these problems is
to supply what is missing. The <TT>md_*</TT> files exist for this
purpose. You should make a copy of the appropriate Make2.___ file,
patch it to define something to identify the system, then patch the
<TT>md.h</TT> and <TT>md.cc</TT> as appropriate. You should not use any
<TT>#ifdef</TT>'s except in these file.<BR>
<BR>
<DT><B>bad header files</B><DD> In some cases, the header files that come
with the system or compiler are defective and generate warnings
without anything wrong with the program being compiled. This slips
by in the distribution because most developers compile with warnings
off. Usually, these can be ignored.</DL>
Here are some problems that have work-arounds:
<DL COMPACT=compact><DT><B>const</B><DD> C++ uses an abstract notion of constant, meaning that
the external appearance of an object declared const must not change,
but there can be internal changes like reference counters. The
keyword <TT>mutable</TT> means that a member variable can change even if it
is declared const. As a work around, we use CONST, which is either
defined to nothing or const. For any good compiler, the line <TT>#define CONST const</TT> will give correct behavior. For a bad compiler,
the line <TT>#define CONST</TT> will turn it off. There is no harm in
treating all compilers as ``bad'' except for the loss of compile
diagnostics.<BR>
<BR>
<DT><B>complex</B><DD> The evolving standard shows complex to be a template
class, so instead of having a type <TT>complex</TT>, there is <TT>complex&lt;double&gt;</TT>, <TT>complex&lt;float&gt;</TT>, and so on. Older compilers
have only <TT>complex</TT>. The line <TT>typedef std::complex&lt;double&gt;
COMPLEX;</TT> in <TT>md.h</TT> works for a correct compiler. You may need to
change it of an older one.<BR>
<BR>
<DT><B>template instantiation</B><DD> There are three common ways to
instantiate templates in common use. Unfortunately, they are
incompatible and none of the methods are available in all compilers.
Gnucap requires templates, so will not work with many older compilers.
<DL COMPACT=compact><DT><B>Link time</B><DD> The entire program is compiled and linked without
templates, resulting in some unresolved externals. The files
defining the templates are compiled again to fill the need. This
is the preferred way, if you have it. It is supported by CFRONT
derivatives such as the Sun CC compiler. Define <TT>LINK_TEMPLATES</TT> to
force it. <BR>
<BR>
<DT><B>Compile time</B><DD> All parts of templates must be compiled as if
in-line, requiring all code to be in the .h file, or included by the
.h file. Header files must include .cc files. The duplicates are
supposed to be thrown away by the linker. This is the only style
supported by Borland 3.1 or 4.0. It is supported inefficiently by the
GNU compiler starting at version 2.6. Since no mainstream compiler requires this, and it is inefficient, it is no longer supported.<BR>
<BR>
<DT><B>manual</B><DD> Templates must be instantiated manually. This is
the preferred way for the GNU and Microsoft compilers. It is a
nuisance, but it generates the best code. Define <TT>MANUAL_TEMPLATES</TT> to
force it.</DL><BR>
<BR>
<DT><B>template resolution</B><DD> The second inconsistency with templates
is how the type matching is resolved. Some compilers require an exact
match. Some will make trivial conversions, such as int to const int.
The language definition allows for templates to be ``specialized'' by
providing a specific implementation for a specific type, resorting to
the template for others. Some compilers (Sun) do not support this.
Since this is common, there are work arounds in the code for it in the
simulator but not the model compiler. If you want to compile the
model compiler, you will need to get a better C++ compiler.</DL>
The files starting with <TT>plot</TT> contain plotting drivers are
generally bogus.<BR>
<BR>
There should be NO non-portable code anywhere but the <TT>md_*</TT>
files. If a fix is absolutely necessary elsewhere, <TT>#define</TT> some
symbol in <TT>md.h</TT> and refer to it elsewhere. Then consider it to
be temporary.<BR>
<BR>
</BODY>
</HTML>
